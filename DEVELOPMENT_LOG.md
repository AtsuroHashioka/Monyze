# Monyze 開発記録

このファイルは、Monyzeプロジェクトの開発過程における重要な決定、実装ステップ、遭遇した問題とその解決策などを記録するためのものです。

---

## 開発計画

### フェーズ1: 基盤構築とユーザー認証 (完了)

*   [x] **データベース環境の構築**: Docker ComposeによるPostgreSQL環境の整備。
*   [x] **データベーススキーマの設計**: Prismaによる`User`, `Transaction`モデルの定義とマイグレーション。
*   [x] **認証バックエンドの実装**: NextAuth.jsとbcryptによる認証ロジックの構築。

### フェーズ2: 認証・登録UIの実装

*   [ ] **新規登録APIの作成**: ユーザー情報をデータベースに保存するAPIエンドポイントを作成する。
*   [ ] **UIコンポーネントの作成**: ログインフォーム、新規登録フォームなどのUIを実装する。
*   [ ] **認証状態の管理**: ログイン状態に応じて表示を切り替える処理を実装する。

### フェーズ3: 家計簿機能の実装

*   [ ] **収支登録フォームの作成**: 収入・支出を登録するUIを作成する。
*   [ ] **収支登録APIの作成**: 登録されたデータをデータベースに保存するAPIを作成する。
*   [ ] **収支一覧表示**: 登録された収支データを一覧で表示するページを作成する。

---

## 開発記録

## 1. データベースの準備：Dockerで「データの保管庫」を用意しよう

アプリのデータ（ユーザー情報や収支記録）を保存する場所が必要です。これを「データベース」と呼びます。今回はPostgreSQLというデータベースを使いますが、PCに直接インストールするのではなく、「Docker」という便利なツールを使います。

**Dockerとは？**
あなたのPCの中に、他の環境から隔離された仮想的な「開発部屋（コンテナ）」を作ってくれるツールです。この部屋の中にデータベースを置くことで、あなたのPC本体の環境を汚さずに済み、後片付けも簡単になります。

---

### 手順1: データベースの「設計図」を作る (`docker-compose.yml`)

まず、Dockerに「どんな開発部屋を作ってほしいか」を指示する設計図ファイル (`docker-compose.yml`) を用意します。

```dockercompose
version: '3.8'

services:
  db:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_DB: monyze
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```

### 手順2: パスワードを「秘密のメモ」に書く (`.env`)

設計図に直接パスワードを書くのは危険です。そこで、別の「秘密のメモ」ファイル (`.env`) を作り、そこにパスワードを書いておきます。このファイルは `.gitignore` に記載して、GitHubなどにはアップロードしないようにします。

### 手順3: データベースを起動する！

設計図と秘密のメモができたので、Dockerに開発部屋を作ってもらいましょう。プロジェクトのルートディレクトリで以下のコマンドを実行します。

```bash
# 設計図を元に、バックグラウンドで開発部屋を起動して！
docker-compose up -d
```

これで、あなたのPCの裏側でPostgreSQLデータベースが動き始めました！

---

## 2. データベースの設計：Prismaで「データの形」を決めよう

データベースが用意できたので、次に「どんなデータを保存するか」の設計をします。ここで登場するのが「Prisma」です。

**Prismaとは？**
アプリ（Next.js）とデータベース（PostgreSQL）の間に立ってくれる「通訳」です。Prismaを使えば、難しいデータベース言語（SQL）を書かなくても、簡単にデータを操作できます。

### 手順1: Prismaの初期設定と「設計書」の作成

まず、Prismaをインストールし、初期設定を行います。

```bash
# frontendディレクトリに移動
cd frontend
# Prismaをインストール
npm install prisma --save-dev
# Prismaの初期設定（schema.prismaファイルなどが作られる）
npx prisma init
```

次に、Prismaの「設計書」である `schema.prisma` ファイルに、どんなデータを保存したいかを書いていきます。

### 手順2: アプリにデータベースの「住所」を教える

Prismaがデータベースに接続できるよう、`frontend/.env` ファイルにデータベースの「住所」(`DATABASE_URL`)を教えます。

### 手順3: 設計書をデータベースに反映させる（マイグレーション）

最後に、Prismaの設計書を、Dockerで動いている実際のデータベースに反映させます。この作業を「マイグレーション」と呼びます。

```bash
# 設計書（schema.prisma）の通りに、データベースのテーブルを作って！
npx prisma migrate dev --name init_user_and_transaction_tables
```

---

## 3.【重要】よくあるトラブルと解決策

マイグレーション実行時に `Authentication failed` (認証失敗) というエラーが出ることがあります。

**原因:**
Dockerで一度作ったデータベースは、最初のユーザー名とパスワードを記憶しています。後からパスワードなどを変更しても、古いデータが残っていると、新しいパスワードでログインできません。

**解決策:**
古いデータベースのデータごと、コンテナを完全に削除して作り直します。

```bash
# プロジェクトのルートディレクトリで実行

# コンテナと、データ保管場所（ボリューム）も一緒に削除して！
docker-compose down -v

# もう一度、まっさらな状態でコンテナを起動して！
docker-compose up -d
```

この後、再度 `npx prisma migrate dev` を実行すれば、今度は成功するはずです。

---

## 4. ユーザー認証の準備：NextAuth.jsでログインの仕組みを作ろう

データベースの土台ができたので、次はユーザーがログイン・新規登録するための仕組みを作ります。これには`NextAuth.js`という認証の専門家ライブラリを使います。

### 手順1: 必要な道具（ライブラリ）をインストール

認証機能とパスワードを安全に管理するための道具をインストールします。

```bash
# frontendディレクトリで実行
npm install next-auth bcrypt
npm install --save-dev @types/bcrypt
```
*   `next-auth`: ログインやログアウトの仕組みを簡単に作れるライブラリ。
*   `bcrypt`: パスワードを安全な暗号に変換してくれるライブラリ。

### 手順2: データベースとの「専用通路」を作成

アプリがデータベースと効率よく通信するための専用ファイル (`/src/lib/prisma.ts`) を作成します。これにより、不必要なデータベース接続が増えるのを防ぎ、アプリを安定させます。

### 手順3: 認証の「司令塔」を作成

NextAuth.jsが認証処理を行うための中心的なファイル (`/src/app/api/auth/[...nextauth]/route.ts`) を作成します。

このファイルは、いわば**認証機能の「司令塔」**です。例えるなら、ビルの受付セキュリティシステムの設定ファイルのような役割を担います。

#### `route.ts` の主な役割

1.  **認証方法の定義 (`providers`)**
    *   「どうやって本人確認をするか？」を定義します。今回は`CredentialsProvider`を使用し、「メールアドレスとパスワード」で認証するルールを設定しました。

2.  **本人確認の具体的な手順 (`authorize`関数)**
    *   セキュリティスタッフが行う実際の確認手順です。
    *   **① ユーザー検索**: フォームから送られてきたメールアドレスを元に、Prismaを使ってデータベース（`User`テーブル）からユーザーを探します。
    *   **② パスワード照合**: ユーザーが見つかった場合、フォームから送られてきたパスワードと、データベースに保存されている暗号化されたパスワード（ハッシュ）が一致するかを`bcrypt.compare`で安全に比較します。
    *   **③ 結果を返す**: 認証に成功すればユーザー情報を返し、失敗すれば`null`を返してログインを拒否します。

3.  **セッション管理 (`session`)**
    *   「一度本人確認が済んだ人に、どうやって「通行許可証（セッション）」を渡すか？」という方法を決めています。`"jwt"`戦略を使うことで、安全な電子通行証（JWT）を発行するように設定しました。

4.  **コールバック処理 (`callbacks`)**
    *   ログイン成功後、通行許可証（JWTやセッション情報）にユーザーIDなどの追加情報を書き込むための処理です。これにより、アプリケーションの他の場所で「今ログインしているのは誰か」を簡単に識別できるようになります。

5.  **各種ページの指定 (`pages`)**
    *   カスタムのログインページやエラーページのURLを指定します。

このファイルに、「メールアドレスとパスワードが送られてきたら、データベースの情報と照合して本人確認を行う」という具体的なロジックを記述することで、NextAuth.jsが自動的にログイン用のAPIエンドポイント(`/api/auth/callback/credentials`)などを生成し、認証プロセス全体を管理してくれます。

### 手順4: セキュリティのための「秘密の鍵」を設定

ログイン状態を安全に保つための「秘密の鍵」(`NEXTAUTH_SECRET`) を生成し、`frontend/.env` ファイルに設定しました。これにより、第三者がセッション情報を盗み見るのを防ぎます。

### 次のステップ
これで、ユーザー認証機能のバックエンド（裏側の処理）の準備が整いました。
次のステップでは、ユーザーが実際にメールアドレスやパスワードを入力するための「ログインページ」や「新規登録ページ」の見た目（UI）を作成していきます。

---

## 5. 認証機能の改善と環境整備

### 手順1: 認証機能の型定義拡張

`route.ts`内で、セッション情報にユーザーIDを追加する際にTypeScriptの型警告が発生しました。これは、NextAuth.jsのデフォルトの型定義に`id`プロパティが存在しないことが原因でした。

**解決策:**
`frontend/src/types/next-auth.d.ts`という型定義拡張ファイルを作成し、`Session`と`JWT`の型に`id`プロパティを追加しました。これにより、型安全性を確保し、コードの信頼性を向上させました。

### 手順2: Git管理対象外ファイルの見直し

プロジェクトに不要なファイル（環境変数ファイル、ビルド成果物、OS固有のファイルなど）がGitリポジトリに含まれないように、プロジェクトルートと`frontend`ディレクトリにある`.gitignore`ファイルの内容を見直しました。

Next.jsプロジェクトのベストプラクティスに基づいた設定を追加・整理することで、リポジトリをクリーンに保ち、開発者間での環境差異による問題を未然に防ぎます。

### 次のステップ

認証機能のバックエンド実装が完了し、環境も整いました。引き続き、UIコンポーネントの実装に進みます。

---

## 6. 新規登録APIの実装

開発計画フェーズ2の最初のタスクとして、ユーザーが新しくアカウントを作成するためのAPIエンドポイントを実装しました。

### なぜ必要か？

ユーザーがWebサイトのフォームから入力した情報（名前、メールアドレス、パスワード）を受け取り、安全に加工してデータベースに新しいユーザーとして登録するための「受付窓口」となる機能です。

### 実装内容

`frontend/src/app/api/register/route.ts` に、以下のロジックを実装しました。

1.  **リクエストから情報を取得**:
    *   フロントエンドから送られてくる`POST`リクエストのボディ（`body`）から、`name`, `email`, `password`をJSON形式で受け取ります。

2.  **入力値のチェック（バリデーション）**:
    *   ユーザーが必須項目をすべて入力しているかを確認します。もし空の項目があれば、「入力してください」というメッセージと共にエラー（ステータスコード `400`）を返します。これは、不完全なデータがデータベースに登録されるのを防ぐための「門番」の役割です。

3.  **メールアドレスの重複チェック**:
    *   受け取ったメールアドレスが既にデータベースに存在しないか、Prismaを使って検索します。もし同じメールアドレスが見つかれば、「このメールアドレスは使われています」というメッセージと共にエラー（ステータスコード `409`）を返します。これにより、一意であるべきメールアドレスが重複するのを防ぎます。

4.  **パスワードの安全な暗号化（ハッシュ化）**:
    *   ユーザーが入力したパスワードを、そのままデータベースに保存するのは非常に危険です。`bcrypt`というライブラリを使い、パスワードを元に戻せない複雑な文字列（ハッシュ）に変換します。これにより、万が一データベースの情報が漏洩しても、ユーザーのパスワードは安全に保たれます。

5.  **データベースへのユーザー登録**:
    *   すべてのチェックを通過したら、Prismaを使って`User`テーブルに新しいユーザーのレコードを作成します。保存するのは、名前、メールアドレス、そして暗号化されたパスワードです。

6.  **結果をフロントエンドに通知**:
    *   登録が成功したら、作成されたユーザー情報と共に「成功しました」の合図（ステータスコード `201`）を返します。
    *   もし途中で予期せぬエラーが発生した場合は、「サーバー内部でエラーが起きました」というメッセージ（ステータスコード `500`）を返します。

これで、フロントエンドから送られてきたユーザー情報を安全に受け取り、データベースに登録するためのバックエンドの準備が整いました。

---

## 7. 新規登録UIの実装

バックエンドに新規登録APIができたので、次はいよいよユーザーが情報を入力するための「見た目」の部分（UI）を作成しました。

### なぜ必要か？

ユーザーがブラウザ上で直感的に操作できるフォーム画面がなければ、せっかく作ったAPIも使ってもらえません。名前、メールアドレス、パスワードを入力し、「登録」ボタンを押せる画面を作ることで、初めてユーザーはサービスに登録できます。

### 実装内容

1.  **UIコンポーネントの作成**:
    *   `frontend/src/components/RegisterForm.tsx` というファイルを作成し、フォームの見た目とロジックをカプセル化（ひとまとめに）しました。
    *   このコンポーネント内で、`useState`を使ってユーザーの入力内容（名前、メールアドレス、パスワード）やエラーメッセージを管理しています。

2.  **フォームの送信処理**:
    *   ユーザーが「登録」ボタンを押したときに実行される`handleSubmit`関数を実装しました。
    *   この関数の中で、`fetch` APIを使い、`/api/register` エンドポイントに入力されたデータを`POST`リクエストとして送信しています。

3.  **APIとの連携と結果の表示**:
    *   APIからのレスポンスを受け取り、成功したか失敗したかを判断します。
    *   登録に成功した場合、`useRouter`を使ってログインページ（`/auth/signin`）へ自動的に遷移させます。
    *   登録に失敗した場合（例: メールアドレスの重複など）、APIから返されたエラーメッセージを画面に表示して、ユーザーに知らせます。

4.  **ページの作成**:
    *   `frontend/src/app/register/page.tsx` を作成し、上記で作った`RegisterForm`コンポーネントを配置しました。これにより、ユーザーが `http://localhost:3000/register` にアクセスすると、新規登録フォームが表示されるようになります。

---

## 8. CSS Modules を使ったUIスタイリング

当初Tailwind CSSの導入を試みましたが、環境起因の問題が発生したため、Next.jsで標準サポートされている「CSS Modules」方式に切り替えて、新規登録フォームとログインフォームのスタイリングを行いました。

### なぜ CSS Modules を使うのか？

*   **スタイルの衝突防止**: 各コンポーネントのCSSクラス名が自動的にユニークになるため、他のコンポーネントのスタイルと衝突する心配がありません。
*   **シンプルな記述**: 通常のCSSと同じ記法でスタイルを記述できます。
*   **Next.jsで標準サポート**: 特別な設定やライブラリのインストールが不要で、すぐに利用開始できます。

### 実装内容

1.  **グローバルCSSの調整 (`src/app/globals.css`)**:
    *   `body`タグの基本的なフォントや背景色、ページ全体を中央に配置するためのレイアウトスタイル（`pageContainer`、`pageTitle`クラス）を定義しました。これは、アプリケーション全体で共通して適用されるスタイルです。

2.  **新規登録フォームのスタイリング (`RegisterForm.tsx` と `RegisterForm.module.css`)**:
    *   `frontend/src/components/RegisterForm.module.css` ファイルを作成し、フォームの見た目に関するCSSルールを記述しました。
    *   `RegisterForm.tsx` コンポーネント内でこのCSSファイルをインポートし、`styles.クラス名` の形式でHTML要素に適用しました。
    *   フォーム全体を中央に配置し、背景色、影、角丸を適用するスタイルや、入力欄、ボタン、エラーメッセージなどの基本的なデザインを設定しました。

3.  **ログインフォームのスタイリング (`LoginForm.tsx` と `LoginForm.module.css`)**:
    *   新規登録フォームと同様に、`frontend/src/components/LoginForm.module.css` ファイルを作成し、ログインフォーム専用のスタイルを記述しました。
    *   `LoginForm.tsx` コンポーネント内でこのCSSファイルをインポートし、HTML要素に適用しました。
    *   新規登録フォームと一貫性のあるデザインになるように、同様のスタイルを適用しています。

4.  **ページのレイアウト調整 (`register/page.tsx` と `auth/signin/page.tsx`)**:
    *   各ページコンポーネントで `globals.css` をインポートし、`pageContainer` や `pageTitle` といったグローバルクラスを適用することで、フォームが画面の中央に配置されるように調整しました。

### 今後の展望

これで、Next.jsの標準機能であるCSS Modulesを使って、フォームに基本的なデザインを適用できました。この方法であれば、追加のライブラリインストールによる問題は発生しにくいと考えられます。

---

## 8. CSS Modules を使ったUIスタイリング

Tailwind CSSの導入で問題が発生したため、Next.jsで標準サポートされている「CSS Modules」を使って、新規登録フォームとログインフォームのスタイリングを行いました。

### なぜ CSS Modules を使うのか？

*   **スタイルの衝突防止**: 各コンポーネントのCSSクラス名が自動的にユニークになるため、他のコンポーネントのスタイルと衝突する心配がありません。
*   **シンプルな記述**: 通常のCSSと同じ記法でスタイルを記述できます。
*   **Next.jsで標準サポート**: 特別な設定やライブラリのインストールが不要で、すぐに利用開始できます。

### 実装内容

1.  **グローバルCSSの調整 (`src/app/globals.css`)**:
    *   `body`タグの基本的なフォントや背景色、ページ全体を中央に配置するためのレイアウトスタイル（`pageContainer`、`pageTitle`クラス）を定義しました。これは、アプリケーション全体で共通して適用されるスタイルです。

2.  **新規登録フォームのスタイリング (`RegisterForm.tsx` と `RegisterForm.module.css`)**:
    *   `frontend/src/components/RegisterForm.module.css` ファイルを作成し、フォームの見た目に関するCSSルールを記述しました。
    *   `RegisterForm.tsx` コンポーネント内でこのCSSファイルをインポートし、`styles.クラス名` の形式でHTML要素に適用しました。
    *   フォーム全体を中央に配置し、背景色、影、角丸を適用するスタイルや、入力欄、ボタン、エラーメッセージなどの基本的なデザインを設定しました。

3.  **ログインフォームのスタイリング (`LoginForm.tsx` と `LoginForm.module.css`)**:
    *   新規登録フォームと同様に、`frontend/src/components/LoginForm.module.css` ファイルを作成し、ログインフォーム専用のスタイルを記述しました。
    *   `LoginForm.tsx` コンポーネント内でこのCSSファイルをインポートし、HTML要素に適用しました。
    *   新規登録フォームと一貫性のあるデザインになるように、同様のスタイルを適用しています。

4.  **ページのレイアウト調整 (`register/page.tsx` と `auth/signin/page.tsx`)**:
    *   各ページコンポーネントで `globals.css` をインポートし、`pageContainer` や `pageTitle` といったグローバルクラスを適用することで、フォームが画面の中央に配置されるように調整しました。

### 今後の展望

これで、Next.jsの標準機能であるCSS Modulesを使って、フォームに基本的なデザインを適用できました。この方法であれば、追加のライブラリインストールによる問題は発生しにくいと考えられます。

---

## 9. UIデザインの改善と英語化

アプリケーションの第一印象を向上させるため、ログイン画面と新規登録画面のデザインを、よりモダンで落ち着いた雰囲気に統一しました。また、グローバルな利用を想定し、UI上の文言をすべて英語に統一しました。

### 主な変更点

1.  **デザインの統一**:
    *   `LoginForm.module.css` と `RegisterForm.module.css` のスタイル定義を共通化し、両方のフォームで一貫したデザインが適用されるようにしました。

2.  **モダンな雰囲気への刷新**:
    *   **配色**: 全体の背景色を明るいグレー (`#f3f4f6`) に設定し、フォームのコンテナにはクリーンな白 (`#ffffff`) を採用しました。ボタンやフォーカス時の色には落ち着いたインディゴ (`#4f46e5`) を使用し、アクセントを加えています。
    *   **角丸と影**: 角の丸みを少し大きく (`0.75rem`) し、より柔らかい印象にしました。また、影 (`box-shadow`) をより繊細なものに変更し、フォームが背景から浮き上がるような立体感を演出しています。
    *   **フォントと余白**: グローバルCSS (`globals.css`) でベースフォントに `Inter` を指定し、モダンなタイポグラフィを目指しました。また、フォーム内外の余白 (`padding`, `gap`) を調整し、全体的にゆとりのある、見やすいレイアウトにしました。

3.  **インタラクティブ性の向上**:
    *   入力欄 (`input`) がフォーカスされた際に、枠線の色と影が変化するインタラクションを追加しました。これにより、ユーザーはどの入力欄を操作しているかを直感的に認識できます。

4.  **UIの英語化**:
    *   ログイン、新規登録フォームのラベル（`Email`, `Password`など）、ボタン（`Log in`, `Register`など）、ページのタイトル（`Log in to Monyze`など）をすべて英語に統一しました。

### 今後の展望

基本的なUIの見た目が整ったことで、より快適なユーザー体験の土台ができました。今後は、認証状態に応じたヘッダーの表示切り替えなど、さらに機能的なUIの構築に進んでいきます。

---

## 16. ソーシャルログイン機能（Google）の実装

ユーザー登録・ログインの利便性を大幅に向上させるため、Googleアカウントを使用したソーシャルログイン機能を実装しました。

### 実装内容

1.  **Googleプロバイダーの追加**:
    *   `next-auth`の設定ファイル (`...nextauth]/route.ts`) に `GoogleProvider` を追加しました。
    *   認証に必要な `GOOGLE_CLIENT_ID` と `GOOGLE_CLIENT_SECRET` を環境変数から読み込むように設定しました。

2.  **環境変数の設定**:
    *   Google Cloud PlatformでOAuth 2.0クライアントIDを作成し、発行されたクライアントIDとシークレットを `.env` ファイルに設定する手順を整備しました。
    *   開発環境でのコールバックURIとして `http://localhost:3000/api/auth/callback/google` を登録しました。

3.  **UIの追加**:
    *   `SocialLoginButtons.tsx` コンポーネントを新規作成し、GoogleログインボタンのUIと `signIn('google')` を呼び出すロジックを実装しました。
    *   ログインページ (`auth/signin/page.tsx`) に、従来のメール/パスワード認証フォームとソーシャルログインボタンを区切るためのUI（"OR"の区切り線）を追加し、作成したボタンを配置しました。

これにより、ユーザーはパスワードを管理することなく、信頼できるGoogleアカウントを通じて安全かつ簡単にサービスを利用開始できるようになりました。

---

## 10. UIデザインの微調整

ユーザーからのフィードバックに基づき、フォームのデザインを微調整しました。

*   **フォームの対称性**: フォームコンテナの `width` を `100%` に変更し、`max-width` で幅を制御するようにしました。これにより、様々な画面サイズでより安定して中央に配置され、左右対称な印象が強まりました。
*   **ボタンのサイズ**: ボタンの垂直方向の余白 (`padding`) を少し減らし（`0.6rem` -> `0.5rem`）、よりコンパクトでシャープな見た目に変更しました。

これらの変更により、全体のバランスが改善され、より洗練されたUIになりました。

---

## 10. UIデザインの微調整

ユーザーからのフィードバックに基づき、フォームのデザインを微調整しました。

*   **フォームの対称性**: フォームコンテナの最大幅 (`max-width`) を少し狭く（`22rem`）することで、よりコンパクトで左右対称な印象になるように調整しました。
*   **ボタンのサイズ**: ボタンの垂直方向の余白 (`padding`) を少し減らし、よりシャープな見た目に変更しました。

これらの変更により、全体のバランスが改善され、より洗練されたUIになりました。

---

## 11. フォームレイアウトの調整

フォーム内のレイアウトについて、ラベルは左揃えのまま、入力欄（input）を中央に配置するよう調整しました。
入力欄の幅を90%に設定し、左右の `margin` を `auto` にすることで、コンテナ内での中央配置を実現しています。これにより、視覚的なバランスがさらに向上しました。

---

## 12. 色彩設計の統一

アプリケーション全体のデザインに一貫性を持たせ、より洗練された印象を与えるため、色彩設計に以下のルールを適用しました。

1.  **基本色を寒色系に限定**:
    *   アクセントカラーやインタラクションを示す色として、インディゴ系の青色 (`#4f46e5` など) を基本としました。

2.  **モノクロ色の厳格化**:
    *   背景、テキスト、境界線などに使用するグレー系の色は、すべてRGB値が同一の純粋なモノクロ（例: `#f5f5f5`, `#cccccc`, `#555555`）に統一しました。これにより、意図しない色味の混入を防ぎ、クリーンな印象を強めています。

3.  **エラー表示色の変更**:
    *   従来、エラー表示に一般的に使われる赤色（暖色）を使用していましたが、色彩ルールを統一するため、これを寒色系の青をベースにしたデザインに変更しました。背景に薄い青、境界線とテキストに濃い青を使用することで、ルールを守りつつ、ユーザーの注意を引くように工夫しました。

---

## 13. エラー表示色の再変更

色彩設計の統一ルールを適用しましたが、エラー表示については、ユーザーが直感的に「間違い」や「警告」を認識できることが最も重要であると判断しました。

そのため、一度寒色系に変更したエラー表示の色を、再度一般的な赤色ベースのデザインに戻しました。これにより、アプリケーション全体のデザイン性と、エラー発生時の視認性・利便性（ユーザビリティ）のバランスを取りました。

---

## 14. 認証ページのナビゲーション改善

ユーザーがログインページと新規登録ページをスムーズに行き来できるよう、相互にリンクを設置しました。

*   **ログインページ**: 「Don't have an account? Register」というテキストと、新規登録ページ (`/register`) へのリンクを追加しました。
*   **新規登録ページ**: 「Already have an account? Log in」というテキストと、ログインページ (`/auth/signin`) へのリンクを追加しました。

これにより、ユーザーが誤ったページにアクセスした場合でも、簡単に目的のページへ移動できるようになり、ユーザー体験が向上しました。

---

## 15. 認証状態に応じたヘッダーの実装

ユーザーのログイン状態に応じて、ヘッダーの表示が動的に切り替わる機能を実装しました。これにより、ユーザーは自身の認証状態を常に把握でき、必要な操作（ログイン、ログアウトなど）へ素早くアクセスできます。

### 実装内容

1.  **`AuthProvider` コンポーネントの作成**:
    *   NextAuth.jsが提供する `SessionProvider` をラップする `AuthProvider` を作成しました。これをルートレイアウトで使用することで、アプリケーション内のどのクライアントコンポーネントからでも `useSession` フックを通じてセッション情報にアクセスできるようになります。

2.  **`Header` コンポーネントの作成**:
    *   `"use client"` ディレクティブを持つクライアントコンポーネントとして `Header.tsx` を作成しました。
    *   `useSession` フックを使って現在のセッション状態（`loading`, `authenticated`, `unauthenticated`）を取得します。
    *   取得した状態に応じて、表示する内容を条件分岐で切り替えています。
        *   **ログイン時**: ユーザー名と、「Log out」ボタン（クリックで `signOut` 関数を実行）を表示します。
        *   **未ログイン時**: 「Log in」と「Register」へのリンクを表示します。

3.  **ルートレイアウトへの組み込み**:
    *   `layout.tsx` を修正し、`<body>` タグ内を `AuthProvider` でラップしました。
    *   作成した `Header` コンポーネントを配置し、その下にページの本体コンテンツが `main` タグ内に表示されるように構造化しました。

これにより、アプリケーションの基本的なナビゲーション構造が完成し、よりWebアプリケーションらしい振る舞いになりました。
