# Monyze 開発記録

このファイルは、Monyzeプロジェクトの開発過程における重要な決定、実装ステップ、遭遇した問題とその解決策などを記録するためのものです。

---

## 開発計画

### フェーズ1: 基盤構築とユーザー認証 (完了)

*   [x] **データベース環境の構築**: Docker ComposeによるPostgreSQL環境の整備。
*   [x] **データベーススキーマの設計**: Prismaによる`User`, `Transaction`モデルの定義とマイグレーション。
*   [x] **認証バックエンドの実装**: NextAuth.jsとbcryptによる認証ロジックの構築。

### フェーズ2: 認証・登録UIの実装

*   [ ] **新規登録APIの作成**: ユーザー情報をデータベースに保存するAPIエンドポイントを作成する。
*   [ ] **UIコンポーネントの作成**: ログインフォーム、新規登録フォームなどのUIを実装する。
*   [ ] **認証状態の管理**: ログイン状態に応じて表示を切り替える処理を実装する。

### フェーズ3: 家計簿機能の実装

*   [ ] **収支登録フォームの作成**: 収入・支出を登録するUIを作成する。
*   [ ] **収支登録APIの作成**: 登録されたデータをデータベースに保存するAPIを作成する。
*   [ ] **収支一覧表示**: 登録された収支データを一覧で表示するページを作成する。

---

## 開発記録

## 1. データベースの準備：Dockerで「データの保管庫」を用意しよう

アプリのデータ（ユーザー情報や収支記録）を保存する場所が必要です。これを「データベース」と呼びます。今回はPostgreSQLというデータベースを使いますが、PCに直接インストールするのではなく、「Docker」という便利なツールを使います。

**Dockerとは？**
あなたのPCの中に、他の環境から隔離された仮想的な「開発部屋（コンテナ）」を作ってくれるツールです。この部屋の中にデータベースを置くことで、あなたのPC本体の環境を汚さずに済み、後片付けも簡単になります。

---

### 手順1: データベースの「設計図」を作る (`docker-compose.yml`)

まず、Dockerに「どんな開発部屋を作ってほしいか」を指示する設計図ファイル (`docker-compose.yml`) を用意します。

```dockercompose
version: '3.8'

services:
  db:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_DB: monyze
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```

### 手順2: パスワードを「秘密のメモ」に書く (`.env`)

設計図に直接パスワードを書くのは危険です。そこで、別の「秘密のメモ」ファイル (`.env`) を作り、そこにパスワードを書いておきます。このファイルは `.gitignore` に記載して、GitHubなどにはアップロードしないようにします。

### 手順3: データベースを起動する！

設計図と秘密のメモができたので、Dockerに開発部屋を作ってもらいましょう。プロジェクトのルートディレクトリで以下のコマンドを実行します。

```bash
# 設計図を元に、バックグラウンドで開発部屋を起動して！
docker-compose up -d
```

これで、あなたのPCの裏側でPostgreSQLデータベースが動き始めました！

---

## 2. データベースの設計：Prismaで「データの形」を決めよう

データベースが用意できたので、次に「どんなデータを保存するか」の設計をします。ここで登場するのが「Prisma」です。

**Prismaとは？**
アプリ（Next.js）とデータベース（PostgreSQL）の間に立ってくれる「通訳」です。Prismaを使えば、難しいデータベース言語（SQL）を書かなくても、簡単にデータを操作できます。

### 手順1: Prismaの初期設定と「設計書」の作成

まず、Prismaをインストールし、初期設定を行います。

```bash
# frontendディレクトリに移動
cd frontend
# Prismaをインストール
npm install prisma --save-dev
# Prismaの初期設定（schema.prismaファイルなどが作られる）
npx prisma init
```

次に、Prismaの「設計書」である `schema.prisma` ファイルに、どんなデータを保存したいかを書いていきます。

### 手順2: アプリにデータベースの「住所」を教える

Prismaがデータベースに接続できるよう、`frontend/.env` ファイルにデータベースの「住所」(`DATABASE_URL`)を教えます。

### 手順3: 設計書をデータベースに反映させる（マイグレーション）

最後に、Prismaの設計書を、Dockerで動いている実際のデータベースに反映させます。この作業を「マイグレーション」と呼びます。

```bash
# 設計書（schema.prisma）の通りに、データベースのテーブルを作って！
npx prisma migrate dev --name init_user_and_transaction_tables
```

---

## 3.【重要】よくあるトラブルと解決策

マイグレーション実行時に `Authentication failed` (認証失敗) というエラーが出ることがあります。

**原因:**
Dockerで一度作ったデータベースは、最初のユーザー名とパスワードを記憶しています。後からパスワードなどを変更しても、古いデータが残っていると、新しいパスワードでログインできません。

**解決策:**
古いデータベースのデータごと、コンテナを完全に削除して作り直します。

```bash
# プロジェクトのルートディレクトリで実行

# コンテナと、データ保管場所（ボリューム）も一緒に削除して！
docker-compose down -v

# もう一度、まっさらな状態でコンテナを起動して！
docker-compose up -d
```

この後、再度 `npx prisma migrate dev` を実行すれば、今度は成功するはずです。

---

## 4. ユーザー認証の準備：NextAuth.jsでログインの仕組みを作ろう

データベースの土台ができたので、次はユーザーがログイン・新規登録するための仕組みを作ります。これには`NextAuth.js`という認証の専門家ライブラリを使います。

### 手順1: 必要な道具（ライブラリ）をインストール

認証機能とパスワードを安全に管理するための道具をインストールします。

```bash
# frontendディレクトリで実行
npm install next-auth bcrypt
npm install --save-dev @types/bcrypt
```
*   `next-auth`: ログインやログアウトの仕組みを簡単に作れるライブラリ。
*   `bcrypt`: パスワードを安全な暗号に変換してくれるライブラリ。

### 手順2: データベースとの「専用通路」を作成

アプリがデータベースと効率よく通信するための専用ファイル (`/src/lib/prisma.ts`) を作成します。これにより、不必要なデータベース接続が増えるのを防ぎ、アプリを安定させます。

### 手順3: 認証の「司令塔」を作成

NextAuth.jsが認証処理を行うための中心的なファイル (`/src/app/api/auth/[...nextauth]/route.ts`) を作成します。

このファイルは、いわば**認証機能の「司令塔」**です。例えるなら、ビルの受付セキュリティシステムの設定ファイルのような役割を担います。

#### `route.ts` の主な役割

1.  **認証方法の定義 (`providers`)**
    *   「どうやって本人確認をするか？」を定義します。今回は`CredentialsProvider`を使用し、「メールアドレスとパスワード」で認証するルールを設定しました。

2.  **本人確認の具体的な手順 (`authorize`関数)**
    *   セキュリティスタッフが行う実際の確認手順です。
    *   **① ユーザー検索**: フォームから送られてきたメールアドレスを元に、Prismaを使ってデータベース（`User`テーブル）からユーザーを探します。
    *   **② パスワード照合**: ユーザーが見つかった場合、フォームから送られてきたパスワードと、データベースに保存されている暗号化されたパスワード（ハッシュ）が一致するかを`bcrypt.compare`で安全に比較します。
    *   **③ 結果を返す**: 認証に成功すればユーザー情報を返し、失敗すれば`null`を返してログインを拒否します。

3.  **セッション管理 (`session`)**
    *   「一度本人確認が済んだ人に、どうやって「通行許可証（セッション）」を渡すか？」という方法を決めています。`"jwt"`戦略を使うことで、安全な電子通行証（JWT）を発行するように設定しました。

4.  **コールバック処理 (`callbacks`)**
    *   ログイン成功後、通行許可証（JWTやセッション情報）にユーザーIDなどの追加情報を書き込むための処理です。これにより、アプリケーションの他の場所で「今ログインしているのは誰か」を簡単に識別できるようになります。

5.  **各種ページの指定 (`pages`)**
    *   カスタムのログインページやエラーページのURLを指定します。

このファイルに、「メールアドレスとパスワードが送られてきたら、データベースの情報と照合して本人確認を行う」という具体的なロジックを記述することで、NextAuth.jsが自動的にログイン用のAPIエンドポイント(`/api/auth/callback/credentials`)などを生成し、認証プロセス全体を管理してくれます。

### 手順4: セキュリティのための「秘密の鍵」を設定

ログイン状態を安全に保つための「秘密の鍵」(`NEXTAUTH_SECRET`) を生成し、`frontend/.env` ファイルに設定しました。これにより、第三者がセッション情報を盗み見るのを防ぎます。

### 次のステップ
これで、ユーザー認証機能のバックエンド（裏側の処理）の準備が整いました。
次のステップでは、ユーザーが実際にメールアドレスやパスワードを入力するための「ログインページ」や「新規登録ページ」の見た目（UI）を作成していきます。

---

## 5. 認証機能の改善と環境整備

### 手順1: 認証機能の型定義拡張

`route.ts`内で、セッション情報にユーザーIDを追加する際にTypeScriptの型警告が発生しました。これは、NextAuth.jsのデフォルトの型定義に`id`プロパティが存在しないことが原因でした。

**解決策:**
`frontend/src/types/next-auth.d.ts`という型定義拡張ファイルを作成し、`Session`と`JWT`の型に`id`プロパティを追加しました。これにより、型安全性を確保し、コードの信頼性を向上させました。

### 手順2: Git管理対象外ファイルの見直し

プロジェクトに不要なファイル（環境変数ファイル、ビルド成果物、OS固有のファイルなど）がGitリポジトリに含まれないように、プロジェクトルートと`frontend`ディレクトリにある`.gitignore`ファイルの内容を見直しました。

Next.jsプロジェクトのベストプラクティスに基づいた設定を追加・整理することで、リポジトリをクリーンに保ち、開発者間での環境差異による問題を未然に防ぎます。

### 次のステップ

認証機能のバックエンド実装が完了し、環境も整いました。引き続き、UIコンポーネントの実装に進みます。

---

## 6. 新規登録APIの実装

開発計画フェーズ2の最初のタスクとして、ユーザーが新しくアカウントを作成するためのAPIエンドポイントを実装しました。

### なぜ必要か？

ユーザーがWebサイトのフォームから入力した情報（名前、メールアドレス、パスワード）を受け取り、安全に加工してデータベースに新しいユーザーとして登録するための「受付窓口」となる機能です。

### 実装内容

`frontend/src/app/api/register/route.ts` に、以下のロジックを実装しました。

1.  **リクエストから情報を取得**:
    *   フロントエンドから送られてくる`POST`リクエストのボディ（`body`）から、`name`, `email`, `password`をJSON形式で受け取ります。

2.  **入力値のチェック（バリデーション）**:
    *   ユーザーが必須項目をすべて入力しているかを確認します。もし空の項目があれば、「入力してください」というメッセージと共にエラー（ステータスコード `400`）を返します。これは、不完全なデータがデータベースに登録されるのを防ぐための「門番」の役割です。

3.  **メールアドレスの重複チェック**:
    *   受け取ったメールアドレスが既にデータベースに存在しないか、Prismaを使って検索します。もし同じメールアドレスが見つかれば、「このメールアドレスは使われています」というメッセージと共にエラー（ステータスコード `409`）を返します。これにより、一意であるべきメールアドレスが重複するのを防ぎます。

4.  **パスワードの安全な暗号化（ハッシュ化）**:
    *   ユーザーが入力したパスワードを、そのままデータベースに保存するのは非常に危険です。`bcrypt`というライブラリを使い、パスワードを元に戻せない複雑な文字列（ハッシュ）に変換します。これにより、万が一データベースの情報が漏洩しても、ユーザーのパスワードは安全に保たれます。

5.  **データベースへのユーザー登録**:
    *   すべてのチェックを通過したら、Prismaを使って`User`テーブルに新しいユーザーのレコードを作成します。保存するのは、名前、メールアドレス、そして暗号化されたパスワードです。

6.  **結果をフロントエンドに通知**:
    *   登録が成功したら、作成されたユーザー情報と共に「成功しました」の合図（ステータスコード `201`）を返します。
    *   もし途中で予期せぬエラーが発生した場合は、「サーバー内部でエラーが起きました」というメッセージ（ステータスコード `500`）を返します。

これで、フロントエンドから送られてきたユーザー情報を安全に受け取り、データベースに登録するためのバックエンドの準備が整いました。

---

## 7. 新規登録UIの実装

バックエンドに新規登録APIができたので、次はいよいよユーザーが情報を入力するための「見た目」の部分（UI）を作成しました。

### なぜ必要か？

ユーザーがブラウザ上で直感的に操作できるフォーム画面がなければ、せっかく作ったAPIも使ってもらえません。名前、メールアドレス、パスワードを入力し、「登録」ボタンを押せる画面を作ることで、初めてユーザーはサービスに登録できます。

### 実装内容

1.  **UIコンポーネントの作成**:
    *   `frontend/src/components/RegisterForm.tsx` というファイルを作成し、フォームの見た目とロジックをカプセル化（ひとまとめに）しました。
    *   このコンポーネント内で、`useState`を使ってユーザーの入力内容（名前、メールアドレス、パスワード）やエラーメッセージを管理しています。

2.  **フォームの送信処理**:
    *   ユーザーが「登録」ボタンを押したときに実行される`handleSubmit`関数を実装しました。
    *   この関数の中で、`fetch` APIを使い、`/api/register` エンドポイントに入力されたデータを`POST`リクエストとして送信しています。

3.  **APIとの連携と結果の表示**:
    *   APIからのレスポンスを受け取り、成功したか失敗したかを判断します。
    *   登録に成功した場合、`useRouter`を使ってログインページ（`/auth/signin`）へ自動的に遷移させます。
    *   登録に失敗した場合（例: メールアドレスの重複など）、APIから返されたエラーメッセージを画面に表示して、ユーザーに知らせます。

4.  **ページの作成**:
    *   `frontend/src/app/register/page.tsx` を作成し、上記で作った`RegisterForm`コンポーネントを配置しました。これにより、ユーザーが `http://localhost:3000/register` にアクセスすると、新規登録フォームが表示されるようになります。

---
